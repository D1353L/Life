#include <iostream>
#include <SFML/Graphics.hpp>
#include <time.h>
#include "LIFE.h"


bool isRealloc=false;

LIFE::LIFE() //конструктор по умолчанию
{
	Field=NULL; rows=0; cols=0;
	cellSizeX=0; cellSizeY=0;
}

LIFE::LIFE(int windowsizex, int windowsizey, int _cellSizeX, int _cellSizeY,  int cellOutlineThickness) //конструктор с параметрами
{
	cellSizeX=_cellSizeX + cellOutlineThickness;
	cellSizeY=_cellSizeY + cellOutlineThickness;

	rows=windowsizex / cellSizeX;
	cols=windowsizey / cellSizeY;

	Field=new cell *[rows];
	for (int i=0; i<rows; i++) Field[i] = new cell [cols];

	//инициализация ячеек(в начале все мертвые)
	for(int x=0; x<rows; x++)
		for(int y=0; y<cols; y++)
		{
			Field[x][y].alive=false;
			Field[x][y].nextAlive=false;
		}
}

LIFE::LIFE(const LIFE &copy_object) //конструктор копирования
{
	Field=NULL;
	rows=copy_object.rows;
	cols=copy_object.cols;	

	cellSizeX=copy_object.cellSizeX;
	cellSizeY=copy_object.cellSizeY;

	Field=new cell *[rows];
	for (int i=0; i<rows; i++) Field[i] = new cell [cols];

	for(int x=0; x<rows; x++)
		for(int y=0; y<cols; y++)
		Field[x][y]=copy_object.Field[x][y];
}

LIFE::~LIFE(void) //деструктор
{
	if(isRealloc)
	{
		for(int x=0; x<rows; x++) free(Field[x]);
		free(Field);
	}
	else
	{
		for(int x=0; x<rows; x++) delete Field[x];
		delete [] Field;
	}
}

int LIFE::GetIndex(int index, int size) //замыкание массива(определяет индексы ячеек, выходящих за рамки массива)
{
    int result = index % size;
    if (result < 0) result = result + size;
    return result;
}

int LIFE::Sum(int x, int y) //сумма живих ячеек-соседей
{
	int xDec, xInc, yDec, yInc;

	//определение ячеек, выходящих за рамки массива
	if((x-1)>=0) xDec=x-1;
	else xDec=GetIndex(x-1, rows);

	if((x+1)<rows) xInc=x+1;
	else xInc=GetIndex(x+1, rows);

	if((y-1)>=0) yDec=y-1;
	else yDec=GetIndex(y-1, cols);

	if((y+1)<cols) yInc=y+1;
	else yInc=GetIndex(y+1, cols);

	//подсчет живых соседей
	return Field[xDec][yDec].alive + Field[x][yDec].alive + Field[xInc][yDec].alive + Field[xDec][y].alive + Field[xInc][y].alive + Field[xDec][yInc].alive + Field[x][yInc].alive + Field[xInc][yInc].alive;
}

void LIFE::Set(char *mode) //начальное заполнение
{	
	if(mode=="random")
	{
	srand(time(NULL));

	for(int x=0; x<rows; x++)
			for(int y=0; y<cols; y++)
				Field[rand()%rows][rand()%cols].alive=true;
	}
	else
		if(mode=="glider")
		{
			Field[1][3].alive=true; Field[2][4].alive=true; Field[3][2].alive=true; 
			Field[3][3].alive=true; Field[3][4].alive=true;
		}
}

void LIFE::GenChange() //смена поколения
{
	int S;

	//подсчет следующего поколения
	for(int x=0; x<rows; x++)
			for(int y=0; y<cols; y++)
			{
				S=Sum(x, y);

				//если в пустой (мёртвой) клетке рядом  ровно три живые клетки, зарождается жизнь
				if( (Field[x][y].alive==false) && (S==3) )
					Field[x][y].nextAlive=true;
				else
				//если у живой клетки есть две или три живые соседки, то эта клетка продолжает жить; в противном случае клетка умирает
					if( (Field[x][y].alive==true) && ( (S==2) || (S==3) ) )
						Field[x][y].nextAlive=true;
					else Field[x][y].nextAlive=false;
			}

	//смена поколения
	for(int x=0; x<rows; x++)
		{
			for(int y=0; y<cols; y++)
			{
				if(Field[x][y].nextAlive==true) Field[x][y].alive=true;
				else Field[x][y].alive=false;
			}
		}
}

/*
void LIFE::Update(int windowsizex, int windowsizey) //изменение количества ячеек
{
	if(rows!=windowsizex/cellSizeX || cols!=windowsizey/cellSizeY)
	{
		rows=windowsizex / cellSizeX;
		cols=windowsizey / cellSizeY;

		*Field=(cell *)realloc(*Field, rows*sizeof(*Field));
			for (int i=0; i<rows; i++) Field[i]=(cell *)realloc(Field[i], cols*sizeof(Field[i]));

		isRealloc=true;
	}
}

void LIFE::Update(int windowsizex, int windowsizey, int _cellSizeX, int _cellSizeY, int _cellOutlineThickness) //изменение параметров поля
{
	if(rows!=windowsizex || cols!=windowsizey || cellSizeX!=_cellSizeX || cellSizeY!=_cellSizeY || cellSizeX!=_cellSizeX+_cellOutlineThickness)
	{
		cellSizeX=_cellSizeX + _cellOutlineThickness;
		cellSizeY=_cellSizeY + _cellOutlineThickness;

		rows=windowsizex / cellSizeX;
		cols=windowsizey / cellSizeY;

		*Field=(cell *)realloc(*Field, rows*sizeof(*Field));
		for (int i=0; i<rows; i++) Field[i]=realloc(Field[i], cols*sizeof(Field[i]));

		isRealloc=true;
	}
}
*/
void LIFE::Output(sf::RenderWindow & window, sf::RectangleShape & rectangle) //вывод
{
	int i=0,j=0;

	//заполнение поля
	for(float x=2.0; x<rows*cellSizeX; x=x+cellSizeX)
	{
		for(float y=2.0; y<cols*cellSizeY; y=y+cellSizeY)
		{
			if(Field[i][j].alive==true) rectangle.setFillColor(sf::Color::Green);
			else rectangle.setFillColor(sf::Color::Black);

			rectangle.setPosition(x, y);
			window.draw(rectangle);
			 j++;
		}
		i++; j=0;
	}
}

int LIFE::getrows()
{
	return rows;
}

int LIFE::getcols()
{
	return cols;
}